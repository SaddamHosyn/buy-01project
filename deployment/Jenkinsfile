pipeline {
    agent any

    parameters {
        choice(name: 'DEPLOY_ENV', choices: ['local', 'staging', 'production'], description: 'Select deployment environment')
        booleanParam(name: 'SKIP_TESTS', defaultValue: false, description: 'Skip tests (use with caution)')
        booleanParam(name: 'FORCE_DEPLOY', defaultValue: false, description: 'Force deployment even if tests fail')
    }

    environment {
        DOCKER_USER          = credentials('docker-hub-username') // Configurable from Jenkins credentials
        REGISTRY_CREDENTIALS = 'docker-hub-credentials'
        BUILD_VERSION        = "${env.BUILD_NUMBER}"
        PREVIOUS_BUILD       = "${env.BUILD_NUMBER.toInteger() - 1}"
    }

    // âš¡ WEBHOOK TRIGGER (Instant builds - webhook configured!)
    triggers {
        githubPush()
    }

    stages {

        stage('Checkout') {
            steps {
                echo "ğŸ“¦ Checking out code..."
                checkout scm
            }
        }

        stage('Secret Scanning') {
            steps {
                echo 'ğŸ” Scanning for accidentally committed secrets...'
                script {
                    def secretsFound = false
                    
                    // AWS Access Key pattern - exclude deployment dir and Jenkinsfile
                    def result1 = sh(script: "grep -r -E -i 'AWS.*ACCESS.*KEY.*=.*[A-Z0-9]{20}' --include='*.java' --include='*.js' --include='*.ts' --include='*.yml' --include='*.properties' --exclude-dir=deployment --exclude-dir=target --exclude-dir=node_modules . || true", returnStdout: true).trim()
                    if (result1) {
                        echo "âš ï¸ Potential AWS Access Key found"
                        secretsFound = true
                    }
                    
                    // AWS Secret Key pattern - exclude deployment dir
                    def result2 = sh(script: "grep -r -E -i 'AWS.*SECRET.*KEY.*=.*[A-Za-z0-9+/]{40}' --include='*.java' --include='*.js' --include='*.ts' --include='*.yml' --include='*.properties' --exclude-dir=deployment --exclude-dir=target --exclude-dir=node_modules . || true", returnStdout: true).trim()
                    if (result2) {
                        echo "âš ï¸ Potential AWS Secret Key found"
                        secretsFound = true
                    }
                    
                    // API Key pattern - only match if followed by actual value (30+ chars)
                    def result3 = sh(script: "grep -r -E -i 'api.?key.*=.*[A-Za-z0-9]{30,}' --include='*.java' --include='*.js' --include='*.ts' --include='*.yml' --include='*.properties' --exclude-dir=deployment --exclude-dir=target --exclude-dir=node_modules . || true", returnStdout: true).trim()
                    if (result3) {
                        echo "âš ï¸ Potential API Key found"
                        secretsFound = true
                    }
                    
                    // Private Key pattern - only in actual key files
                    def result4 = sh(script: "grep -r 'BEGIN.*PRIVATE KEY' --include='*.pem' --include='*.key' --exclude-dir=deployment --exclude-dir=target --exclude-dir=node_modules . || true", returnStdout: true).trim()
                    if (result4) {
                        echo "âš ï¸ Potential Private Key found"
                        secretsFound = true
                    }
                    
                    if (secretsFound) {
                        error('âŒ Secrets detected in code! Please remove them and use Jenkins credentials.')
                    } else {
                        echo 'âœ… No secrets detected in code.'
                    }
                }
            }
        }

        stage('Backend Tests') {
    when {
        expression { params.SKIP_TESTS == false }
    }
    steps {
        echo 'ğŸ§ª Running backend tests...'
        script {
            catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                dir('user-service') {
                    sh 'mvn clean test -Dmaven.test.failure.ignore=false'
                }
                dir('product-service') {
                    sh 'mvn clean test -Dmaven.test.failure.ignore=false'
                }
                dir('media-service') {
                    sh 'mvn clean test -Dmaven.test.failure.ignore=false'
                }
            }
        }
    }
    post {
        always {
            junit allowEmptyResults: true, testResults: '**/target/surefire-reports/*.xml'
            // Archive test coverage reports
            archiveArtifacts artifacts: '**/target/surefire-reports/**, **/target/site/jacoco/**', allowEmptyArchive: true
        }
        failure {
            echo 'âŒ Backend tests failed!'
        }
        success {
            echo 'âœ… Backend tests passed!'
        }
    }
}

        stage('Frontend Tests') {
    when {
        expression { params.SKIP_TESTS == false }
    }
    steps {
        echo 'ğŸ§ª Running frontend tests (Karma/Jasmine)...'
        dir('buy-01-ui') {
            sh '''
                export CHROME_BIN=/usr/bin/chromium
                rm -rf node_modules package-lock.json
                npm install --legacy-peer-deps
                npx ng test --watch=false --browsers=ChromeHeadlessCI --code-coverage
            '''
        }
    }
    post {
        always {
            // Archive frontend test coverage
            archiveArtifacts artifacts: 'buy-01-ui/coverage/**', allowEmptyArchive: true
        }
        failure {
            echo 'âŒ Frontend tests failed!'
        }
        success {
            echo 'âœ… Frontend tests passed!'
        }
    }
}

        stage('Code Quality Check') {
            when {
                expression { params.SKIP_TESTS == false }
            }
            steps {
                echo 'ğŸ“Š Running code quality checks...'
                script {
                    // Checkstyle validation using Sun Java coding standards
                    // Checks: Line length (80 chars), trailing spaces, indentation,
                    // naming conventions, Javadoc, code formatting
                    // Status: Non-blocking warnings (marked UNSTABLE on violations)
                    def services = ['user-service']
                    for (service in services) {
                        dir(service) {
                            catchError(buildResult: 'SUCCESS', stageResult: 'UNSTABLE') {
                                sh 'mvn checkstyle:check'
                            }
                        }
                    }
                    echo 'âœ… Code quality check completed'
                }
            }
            post {
                always {
                    // Archive code quality reports
                    archiveArtifacts artifacts: '**/target/checkstyle-result.xml', allowEmptyArchive: true
                }
            }
        }

        stage('Build Backend JARs') {
            steps {
                echo 'ğŸ“¦ Building backend JAR files...'
                script {
                    catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                        def services = ['service-registry', 'user-service', 'product-service', 'media-service']
                        for (service in services) {
                            dir(service) {
                                sh 'mvn clean package -DskipTests'
                            }
                        }
                    }
                }
            }
        }

        stage('Build Docker Images') {
            steps {
                echo "ğŸ³ Building Docker Images in parallel with tag: ${BUILD_VERSION}..."
                script {
                    parallel(
                        'service-registry': {
                            sh "docker build -t ${DOCKER_USER}/buy-01-service-registry:latest -t ${DOCKER_USER}/buy-01-service-registry:${BUILD_VERSION} ./service-registry"
                        },
                        'api-gateway': {
                            sh "docker build -t ${DOCKER_USER}/buy-01-api-gateway:latest -t ${DOCKER_USER}/buy-01-api-gateway:${BUILD_VERSION} ./api-gateway"
                        },
                        'user-service': {
                            sh "docker build -t ${DOCKER_USER}/buy-01-user-service:latest -t ${DOCKER_USER}/buy-01-user-service:${BUILD_VERSION} ./user-service"
                        },
                        'product-service': {
                            sh "docker build -t ${DOCKER_USER}/buy-01-product-service:latest -t ${DOCKER_USER}/buy-01-product-service:${BUILD_VERSION} ./product-service"
                        },
                        'media-service': {
                            sh "docker build -t ${DOCKER_USER}/buy-01-media-service:latest -t ${DOCKER_USER}/buy-01-media-service:${BUILD_VERSION} ./media-service"
                        },
                        'frontend': {
                            sh "docker build -t ${DOCKER_USER}/buy-01-frontend:latest -t ${DOCKER_USER}/buy-01-frontend:${BUILD_VERSION} ./buy-01-ui"
                        }
                    )
                }
            }
        }

        stage('Push to Docker Hub') {
            when {
                expression {
                    // Only push if all tests passed
                    return currentBuild.result == null || currentBuild.result == 'SUCCESS'
                }
            }
            steps {
                echo "ğŸš€ Pushing images to Docker Hub in parallel..."
                withCredentials([usernamePassword(
                    credentialsId: REGISTRY_CREDENTIALS,
                    usernameVariable: 'DOCKER_USER_CRED',
                    passwordVariable: 'DOCKER_PASS'
                )]) {
                    sh 'echo $DOCKER_PASS | docker login -u $DOCKER_USER_CRED --password-stdin'
                    script {
                        def dockerUser = env.DOCKER_USER
                        def buildVer = env.BUILD_VERSION
                        parallel(
                            'service-registry': {
                                sh "docker push '${dockerUser}/buy-01-service-registry:latest'"
                                sh "docker push '${dockerUser}/buy-01-service-registry:${buildVer}'"
                            },
                            'api-gateway': {
                                sh "docker push '${dockerUser}/buy-01-api-gateway:latest'"
                                sh "docker push '${dockerUser}/buy-01-api-gateway:${buildVer}'"
                            },
                            'user-service': {
                                sh "docker push '${dockerUser}/buy-01-user-service:latest'"
                                sh "docker push '${dockerUser}/buy-01-user-service:${buildVer}'"
                            },
                            'product-service': {
                                sh "docker push '${dockerUser}/buy-01-product-service:latest'"
                                sh "docker push '${dockerUser}/buy-01-product-service:${buildVer}'"
                            },
                            'media-service': {
                                retry(3) {
                                    sh "docker push '${dockerUser}/buy-01-media-service:latest'"
                                }
                                sh "docker push '${dockerUser}/buy-01-media-service:${buildVer}'"
                            },
                            'frontend': {
                                sh "docker push '${dockerUser}/buy-01-frontend:latest'"
                                sh "docker push '${dockerUser}/buy-01-frontend:${buildVer}'"
                            }
                        )
                    }
                }
            }
        }

        stage('Deploy') {
            when {
                expression {
                    // Only deploy if build is successful (no test failures)
                    return currentBuild.result == null || currentBuild.result == 'SUCCESS'
                }
            }
            steps {
                echo "ğŸš€ Deploying to ${params.DEPLOY_ENV} environment..."
                script {
                    env.DEPLOYMENT_FAILED = 'false'
                    catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                    // Helper function: Wait for container to be running
                    def waitForContainer = { String containerName, int maxAttempts ->
                        def attempt = 0
                        def isRunning = false
                        
                        while (attempt < maxAttempts && !isRunning) {
                            attempt++
                            echo "â³ Checking ${containerName}... (${attempt}/${maxAttempts})"
                            
                            def status = sh(
                                script: "docker ps --filter name=${containerName} --format '{{.Status}}' | grep -q 'Up'",
                                returnStatus: true
                            )
                            
                            if (status == 0) {
                                echo "âœ… ${containerName} is running"
                                isRunning = true
                            } else {
                                if (attempt < maxAttempts) {
                                    sleep(1)  // Reduced from 2 to 1 second
                                }
                            }
                        }
                        
                        if (!isRunning) {
                            error("âŒ ${containerName} failed to start after ${maxAttempts} attempts")
                        }
                    }
                    
                    // Helper function: Wait for HTTP health endpoint
                    def waitForServiceHealth = { String healthUrl, int maxAttempts ->
                        def attempt = 0
                        def isHealthy = false
                        
                        while (attempt < maxAttempts && !isHealthy) {
                            attempt++
                            echo "â³ Health check ${healthUrl}... (${attempt}/${maxAttempts})"
                            
                            def status = sh(
                                script: "curl -sf ${healthUrl} > /dev/null 2>&1",
                                returnStatus: true
                            )
                            
                            if (status == 0) {
                                echo "âœ… Service is healthy!"
                                isHealthy = true
                            } else {
                                if (attempt < maxAttempts) {
                                    sleep(2)  // Reduced from 3 to 2 seconds
                                }
                            }
                        }
                        
                        if (!isHealthy) {
                            echo "âš ï¸ Warning: ${healthUrl} not responding (continuing anyway)"
                        }
                    }
                    
                    // Smart deployment: Only restart app services, keep infrastructure running
                    echo "ğŸš€ Deploying application services..."
                    
                    // TEMPORARY: Simulate deployment failure to test rollback
                    echo "âš ï¸ TESTING: Simulating deployment failure..."
                    env.DEPLOYMENT_FAILED = 'true'
                    error('âŒ Simulated deployment failure - Testing rollback mechanism')
                    
                    sh '''
                        cd deployment
                        
                        # Keep infrastructure running (Zookeeper, MongoDB, Kafka)
                        # Only restart application services with new images
                        docker-compose up -d --no-deps --force-recreate service-registry
                        sleep 5
                        
                        docker-compose up -d --no-deps --force-recreate api-gateway user-service product-service media-service frontend
                        sleep 3
                    '''
                    
                    // Quick health verification
                    echo "ğŸ” Verifying deployment..."
                    def healthCheck = sh(
                        script: '''
                            sleep 10
                            
                            if ! docker ps | grep -q "buy-01-service-registry.*Up"; then
                                echo "âŒ service-registry is not running"
                                exit 1
                            fi
                            if ! docker ps | grep -q "buy-01-api-gateway.*Up"; then
                                echo "âŒ api-gateway is not running"
                                exit 1
                            fi
                            
                            echo "âœ… All services deployed and running!"
                            exit 0
                        ''',
                        returnStatus: true
                    )
                    
                    if (healthCheck != 0) {
                        env.DEPLOYMENT_FAILED = 'true'
                        error('âŒ Deployment health check failed!')
                    }
                    } // end catchError
                    
                    if (env.DEPLOYMENT_FAILED == 'true') {
                        error('Deployment failed - triggering rollback')
                    }
                }
            }
        }

        stage('Rollback on Failure') {
            steps {
                script {
                    if (env.DEPLOYMENT_FAILED == 'true') {
                        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                        echo "âš¡ ROLLBACK TRIGGERED!"
                        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                        echo "âŒ Build #${env.BUILD_NUMBER} deployment FAILED"
                        echo "ğŸ”„ Rolling back to stable build #${PREVIOUS_BUILD}"
                        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                        
                        catchError(buildResult: 'FAILURE', stageResult: 'SUCCESS') {
                    echo "ğŸ”„ Rolling back to stable build #${PREVIOUS_BUILD}"
                    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                    
                    catchError(buildResult: 'FAILURE', stageResult: 'SUCCESS') {
                        sh """
                            # Retag cached images
                            docker tag hussainsaddam/buy-01-service-registry:${PREVIOUS_BUILD} hussainsaddam/buy-01-service-registry:latest 2>/dev/null || true
                            docker tag hussainsaddam/buy-01-api-gateway:${PREVIOUS_BUILD} hussainsaddam/buy-01-api-gateway:latest 2>/dev/null || true
                            docker tag hussainsaddam/buy-01-user-service:${PREVIOUS_BUILD} hussainsaddam/buy-01-user-service:latest 2>/dev/null || true
                            docker tag hussainsaddam/buy-01-product-service:${PREVIOUS_BUILD} hussainsaddam/buy-01-product-service:latest 2>/dev/null || true
                            docker tag hussainsaddam/buy-01-media-service:${PREVIOUS_BUILD} hussainsaddam/buy-01-media-service:latest 2>/dev/null || true
                            docker tag hussainsaddam/buy-01-frontend:${PREVIOUS_BUILD} hussainsaddam/buy-01-frontend:latest 2>/dev/null || true
                            
                            # Rolling restart
                            cd deployment
                            docker-compose up -d --no-deps --force-recreate service-registry &
                            sleep 2
                            docker-compose up -d --no-deps --force-recreate api-gateway user-service product-service media-service frontend
                        """
                        }
                        sleep 3
                        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                        echo "âœ… Rollback completed successfully!"
                        echo "ğŸ¯ System restored to build #${PREVIOUS_BUILD}"
                        echo "ğŸ“Š All services running stable version"
                        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                    } else {
                        echo "âœ… No deployment failure - Rollback not needed"
                    }
                }
            }
        }
    }
    post {
        success {
            echo "âœ… Pipeline completed successfully!"
            echo "Build #${env.BUILD_NUMBER} - All stages passed"
            
            // Slack notification
            script {
                try {
                    withCredentials([string(credentialsId: 'slack-webhook-url', variable: 'SLACK_URL')]) {
                        sh '''
                            curl -X POST -H 'Content-type: application/json' \
                            --data "{\\"text\\":\\"âœ… *SUCCESS*: Job ${JOB_NAME} Build #${BUILD_NUMBER}\\\\n${BUILD_URL}\\"}" \
                            ${SLACK_URL}
                        '''
                    }
                } catch (Exception e) {
                    echo "âš ï¸ Slack notification skipped (credential not configured): ${e.message}"
                }
            }
        }
        failure {
            echo "âŒ Pipeline failed!"
            echo "Build #${env.BUILD_NUMBER} - Check logs for details"
            echo "ğŸ”„ Rollback was executed in the 'Rollback on Failure' stage"
            
            // Slack notification
            script {
                try {
                    withCredentials([string(credentialsId: 'slack-webhook-url', variable: 'SLACK_URL')]) {
                        sh '''
                            curl -X POST -H 'Content-type: application/json' \
                            --data "{\\"text\\":\\"âŒ *FAILED*: Job ${JOB_NAME} Build #${BUILD_NUMBER}\\\\n${BUILD_URL}console\\"}" \
                            ${SLACK_URL}
                        '''
                    }
                } catch (Exception e) {
                    echo "âš ï¸ Slack notification skipped (credential not configured): ${e.message}"
                }
            }
        }
        always {
            echo "ğŸ§¹ Cleaning up workspace..."
            // Archive build artifacts before cleanup
            archiveArtifacts artifacts: '**/target/*.jar', allowEmptyArchive: true, fingerprint: true
            cleanWs()
        }
    }
}
